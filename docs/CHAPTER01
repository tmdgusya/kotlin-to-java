# 코틀린에서 자바로 - 1강
Java 8 이전에는 일급 시민인 함수가 없었기 때문에 아래 코틀린 코드와 같은 시도가 불가능했다.
```kotlin
val sum = numbers.fold(0, Int::plus)
```

그래서 자바는 아래와 같은 방식으로 직접 Interface 를 작성해야만 했다.
```java
public interface Function2 {
	Object apply(Object arg1, Object arg2);
}
```

이렇게 정의한 후 fold 메소드도 재정의해줘야만 했다. 자바 1.0 에서는 JIT 컴파일러도 제공하지 않았을 뿐더러 여러 보일러 플레이트를 많이 작성해야만 했고 성능상 좋지 않았다. (Java guava 개발자들도 사용해도 되나 기존의 명령형 식으로 작성하는게 좋다고 적혀있음)

## 코틀린의 결
우리가 코틀린으로 코드를 작성 하더라도 기존 자신이 사용하던 언어의 결을 따르는 경우가 많다. 함수형 언어를 주로 사용하던 사람들은 너무 함수형스럽게 작성하고, Java 개발자는 Util Class 를 굳이 만드는 경우도 있다. 그래서 코틀린을 만든 개발자들이 코틀린이 추구하는 목적을 적어놓은 글이 있는데 요약하자면 아래와같다.

### 코틀린은 가변 상태를 변경하는 것 보다 불변 데이터를 변환하는 쪽을 더 선호한다.
데이터 클래스를 사용하여 값 의미론(value semantics) 을 제공하는 타입을 쉽게 제공할 수 있다. Kotlin 의 Collections API 인 map 함수또한 변환 함수(transform) 을 실행할때 원본을 가공하는것이 아닌 새로운 Collections 를 리턴해준다. 마틴파울러의 리팩토링 저서 혹은 여러 동시성 프로그래밍 책들을 읽다보면 최대한 불변의 데이터를 사용하고 값을 바꿔야 할때는 새롭게 객체를 만들면서 값을 할당하는 방향으로 가는 것 같다.

Q) 책에서 값 의미론(Value Semantics) 의 설명중 Stack 에 data class 의 Instance 가 할당되는 것처럼 나오는데 과연 맞는것인지?

### 코틀린은 동작을 명시적으로 작성하는 쪽을 더 선호한다.
코틀린에는 암시적인 타입 변환이 없다. 심지어 더 작은 데이터 타입을 더 큰 데이터 타입으로 자동으로 변환해주지도 않는다. 예를 들면, Java 에서는 아래와 같은 방법으로 Int 를 long 으로 변환할 수 있다.
```java
int a = 10
long b = a
```

하지만 코틀린에서는 아래와 같이 작성하게 되면 컴파일 에러를 마주하게 된다.
```kotlin
a: Int = 10
b: Long = a
```

코틀린은 강타입언어다. 코틀린에서는 암시적인 타입 변환을 해주지 않는다. 따라서 명시적으로 `toLong()` 과 같은 메소드를 통해 타입을 변환해주어야 한다.

### 코틀린은 동적 바인딩보다 정적 바인딩을 선호한다
대부분의 언어에서 컴파일시간에 에러를 탐지 할 수 있는 것이 런타임에 에러를 탐지하는 것 보다 더 안전하다는 것이 입증되었고 최근에 나온 언어들 중 일부는 컴파일 시간에 에러를 감지하기 위해 노력한다. 코틀린 또한 마찬가지로, 컴파일 타임에 에러를 감지하기 위해 많은 노력을 기울인다.
코틀린의 주요 기능인 **확장함수(Extension Funtion)** 또한 런타임에 동적으로 바인딩 되는 것이 아니라, 정적으로 바인딩 된다.


## Lateinit Interop
코틀린과 같은 강타입 언어에서 `lateinit` 과 같은 기능은 허점을 만들기 때문에 **Java 코드와 같이 사용할때만 이용**해야 한다. `lateinit var` 와 같은 한정자를 이용하면 초기화를 해야할 책임이 개발자에게 생긴다. 초기화 하지 않는다면 `NullPointerException` 이 발생할 수 있다.



#kotlin-to-java #study